# План действий для добавления логики запуска игры

## Шаг 1: Анализ существующей логики и API

*   **Цель:**  Детально изучить текущую реализацию управления сессиями, обработки вопросов, подсчета очков и взаимодействия с игроками.
*   **Actions:**
    1.  **Изучить `docs/game_sessions_logic.md`:**  Разобраться, как сейчас создаются, запускаются и завершаются сессии, как хранится информация о состоянии игры (статус, текущий вопрос, игроки).
    2.  **Изучить `docs/questions_and_answers_logic.md`:**  Понять, как выбираются вопросы для сессии, как они отображаются, как принимаются и проверяются ответы, как начисляются очки.
    3.  **Изучить `docs/players_logic.md`:**  Выяснить, как игроки подключаются к сессии, как их данные хранятся (в Redis), как обрабатываются их ответы.
    4.  **Изучить `docs/api_specification.md`:**  Проанализировать существующие API-методы для управления сессиями (`/api/game_sessions/{gameId}`, `/api/game_sessions/{gameId}/answers`), получения вопросов (`/api/questions`), и, возможно, другие связанные с игроками и сессиями.  Особое внимание уделить форматам запросов и ответов.
*   **Результат:**  Четкое понимание текущей архитектуры, взаимодействия компонентов и потенциальных мест для внесения изменений.

## Шаг 2:  Определение необходимых изменений и дополнений

*   **Цель:**  Сформулировать конкретные задачи по реализации новой функциональности, определить, какие компоненты нужно изменить, какие новые API-методы могут потребоваться.
*   **Actions:**
    1.  **Продумать логику запуска сессии:**
        *   Какие действия должен выполнить администратор для запуска (например, выбор группы вопросов, установка времени на вопрос)?
        *   Как изменяется статус сессии в базе данных (`waiting` → `active`)?  Какой API-метод для этого используется (`PUT /api/game_sessions/{gameId}`)?
        *   Какие данные нужно передать на клиентскую часть для начала игры (например, ID сессии, список игроков, первый вопрос)?
    2.  **Определить процесс отображения вопросов:**
        *   Как клиент получает текущий вопрос для сессии?  Используется ли `question_index` в данных сессии?
        *   Какой API-метод используется для получения вопросов (`GET /api/questions?groupId={groupId}` при создании сессии, возможно, нужен новый метод для получения текущего вопроса в активной сессии)?
        *   Как вопросы отображаются на клиентской стороне (UI)?
    3.  **Реализовать учет времени:**
        *   Где хранится время, отведенное на вопрос (`timePerQuestionInSec` в данных сессии)?
        *   Как клиент получает эту информацию?
        *   Как реализуется таймер на клиентской стороне?
        *   Как обрабатывается ситуация, когда время истекло, а игрок не ответил?
    4.  **Уточнить логику подсчета очков:**
        *   Детально изучить правила подсчета очков для классических и числовых вопросов (см. `docs/blueprint.md`, раздел "Система подсчета очков").
        *   Какие данные необходимы для подсчета (правильный ответ, ответ игрока, время ответа, сложность вопроса)?
        *   Где реализуется логика подсчета (на клиенте или на сервере)?  Какой API-метод используется для отправки ответа и получения результата (`POST /api/game_sessions/{gameId}/answers`)?  Какие данные возвращаются в ответе (например, начисленные очки, правильный ответ)?
        *   Как обновляются очки игрока в Redis?
    5.  **Продумать взаимодействие с игроками:**
        *   Как игроки узнают о начале сессии?  Нужно ли им отправлять уведомления?
        *   Как обрабатываются ситуации, когда игрок подключается к сессии после ее начала?
        *   Как отображаются результаты игрока (текущие очки, рейтинг)?
*   **Результат:**  Список конкретных задач, например:
    *   "Реализовать на клиентской стороне компонент для администратора для запуска сессии (выбор группы вопросов, установка времени на вопрос, кнопка 'Старт')."
    *   "Добавить на сервер API-метод для изменения статуса сессии на 'active' и отправки данных о начале игры клиенту."
    *   "Реализовать на клиентской стороне логику отображения текущего вопроса и вариантов ответа."
    *   "Добавить на клиентской стороне таймер для отсчета времени на вопрос."
    *   "Доработать API-метод `POST /api/game_sessions/{gameId}/answers` для реализации подсчета очков в соответствии с правилами."
    *   "Реализовать на клиентской стороне отображение результатов игрока после ответа (правильность, очки)."
    *   "Рассмотреть возможность добавления уведомлений для игроков о начале сессии."

## Шаг 3:  Разбиение на подзадачи и оценка трудоемкости

*   **Цель:**  Разбить крупные задачи на более мелкие, которые можно выполнять параллельно или последовательно, и оценить примерное время на их выполнение.
*   **Действия:**  Для каждой задачи из Шага 2 составить список подзадач.  Например, для задачи "Реализовать на клиентской стороне компонент для запуска сессии администратором":
    1.  "Создать новый компонент `AdminSessionControl`."
    2.  "Добавить поля для выбора группы вопросов (с выпадающим списком) и установки времени на вопрос (с числовым полем)."
    3.  "Реализовать кнопку 'Старт'."
    4.  "При нажатии кнопки 'Старт' отправлять запрос на сервер (с использованием `fetch` или аналогичной библиотеки) на запуск сессии, передавая необходимые данные (ID группы вопросов, время на вопрос)."
    5.  "Обработать ответ от сервера: в случае успеха вывести сообщение об успешном запуске, в случае ошибки - сообщение об ошибке."
*   **Результат:**  Детализированный план работ с оценкой времени на каждую подзадачу.  Это позволит более эффективно распределять задачи и контролировать процесс разработки.

## Шаг 4:  Реализация и тестирование

*   **Цель:**  Выполнить подзадачи, тщательно тестируя каждый этап.
*   **Actions:**
    1.  Выбрать подзадачу из плана.
    2.  Написать код для ее реализации.
    3.  Провести модульное тестирование (unit tests) для проверки корректности работы отдельных функций и компонентов.
    4.  Провести интеграционное тестирование (integration tests) для проверки взаимодействия с другими частями системы (например, с API).
    5.  При необходимости отладить код, исправить ошибки.
    6.  Задокументировать изменения в коде (комментарии, README).
    7.  Сделать коммит в систему контроля версий (например, Git) с описанием изменений.
    8.  Повторить шаги 1-7 для всех подзадач.
*   **Результат:**  Реализованная и протестированная функциональность.

## Шаг 5:  Интеграция и общее тестирование

*   **Цель:**  Объединить все реализованные части в единое приложение и провести комплексное тестирование.
*   **Actions:**
    1.  Собрать все компоненты и API-методы вместе.
    2.  Провести сквозное тестирование (end-to-end tests), проверяя сценарии использования приложения целиком (например, создание сессии администратором, подключение игроков, ответы на вопросы, завершение сессии).
    3.  Обратить внимание на обработку ошибок, корректность данных, производительность приложения.
    4.  При необходимости исправить обнаруженные ошибки.
*   **Результат:**  Работающее приложение с реализованной логикой запуска игры, отображения вопросов, учета времени и подсчета очков.

## Шаг 6:  Документация и рефакторинг

*   **Цель:**  Завершить работу над функциональностью, улучшив код и подготовив документацию.
*   **Actions:**
    1.  Обновить существующую документацию (`docs/game_sessions_logic.md`, `docs/questions_and_answers_logic.md`, `docs/players_logic.md`, `docs/api_specification.md`) с учетом внесенных изменений.
    2.  Провести рефакторинг кода для улучшения его читаемости, структуры и производительности.
    3.  Добавить или обновить комментарии в коде.
*   **Результат:**  Подробная и актуальная документация, качественный и поддерживаемый код.

## Необходимая информация от вас:

Для более точного планирования и реализации мне потребуется следующая информация:

1.  **Детали UI:**  Как именно должен выглядеть интерфейс администратора для запуска сессии (какие поля, кнопки)?  Есть ли макеты или примеры?
2.  **Уведомления:**  Нужно ли реализовывать уведомления для игроков о начале сессии?  Если да, то какой механизм использовать (например, WebSocket, push-уведомления)?
3.  **API взаимодействия:**  Нужно ли создавать новые API-методы или можно использовать существующие?  Например, достаточно ли метода `PUT /api/game_sessions/{gameId}` для обновления статуса сессии и передачи данных о начале игры, или нужен отдельный метод?  Нужен ли метод для получения текущего вопроса в активной сессии?
4.  **Подсчет очков:**  Есть ли более детальное описание правил подсчета очков (например, формулы, примеры)?
5.  **Обработка времени:**  Как именно нужно обрабатывать ситуацию, когда время на ответ истекло?  Нужно ли автоматически засчитывать ответ как неправильный, или есть другие варианты?

Чем более подробную информацию вы предоставите, тем более точным и эффективным будет план реализации.